# 二叉树03
## 110. Balanced Binary Tree
* https://leetcode.com/problems/balanced-binary-tree/description/
* 文章： https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html
* 视频：https://www.bilibili.com/video/BV1Ug411S7my?vd_source=62d2d5517cc65d630d19b32ed3dcf9c5&spm_id_from=333.788.videopod.sections
* 平衡二叉树定义：树中任意一个节点的两个子树的深度差不能大于1
* 需要判断每一个节点的左右子树的高度（参见day14求二叉树的最大深度），求高度就一定要用后序遍历，求深度就一定要用前序遍历
* **注意递归逻辑**
1. 参数：node，返回值：不仅要记录height，还要记录子树是不是平衡的。解决方法：如果不是平衡的就return-1
2. 终止条件：node=null，return height =0
3. 单层递归逻辑： 检查左右子树是否已经传入了不平衡数据（传入了-1），如果没有，那就计算当前根节点左右子树是否平衡，如果不平衡就传入-1，平衡的话就计算当前根节点的高度（从它到叶子的最长距离）
```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        int result = getHeight(root);
        if (result == -1) return false;
        return true;
    }
    //这个递归函数需要同时记录1）子树是不是平衡2）如果平衡，差值是多少
    private int getHeight(TreeNode node){
        //leetcode中设置空节点高度为0，叶节点的高度为1
        if (node==null) return 0;

        int leftHeight = getHeight(node.left);
        //如果左子树已经不平衡，返回不平衡
        if (leftHeight == -1) return -1;

        int rightHeight = getHeight(node.right);
        if (rightHeight == -1) return -1;

        int res;
        if(Math.abs(leftHeight-rightHeight)>1){
            res = -1;
        }else{
            // 非叶子节点的高度 = 1 + 左右子树的最大高度，因为：一棵树的高度取决于 它最长的子树路径。
            res = 1+Math.max(leftHeight, rightHeight);
        }

        return res;
        
    }
}
```
## 257. Binary Tree Paths
* https://leetcode.com/problems/binary-tree-paths/description/
* 文章： https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE
* 视频：https://www.bilibili.com/video/BV1ZG411G7Dh?vd_source=62d2d5517cc65d630d19b32ed3dcf9c5&spm_id_from=333.788.videopod.sections
### chat解法：string储存path，隐藏回溯
* 采用前序遍历：先append中节点数值，再去访问左右子树
* 直接使用 String，不需要手动回溯（backtr，因为 String 在 Java 中是不可变的（immutable），不会影响上一层。
```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root==null) return res;
        traverse(root,"",res);
        return res;


    }
//这里递归直接对res和path进行改造，就不需要return了，因为我们只需要知道该节点是否是叶子（left和right都为null）
    private void traverse(TreeNode node, String path, List<String> res){
        if (node==null) return;

        path += node.val;

        if(node.left ==null && node.right ==null){
            //一直到叶子的时候我们都在不断构造path，直到叶子，那就把完整的path加到res里，这个时候path归会上一个父节点，再去遍历组装下一个path
            res.add(path);
            return;
        }
        traverse(node.left, path+"->",res);
        traverse(node.right,path+"->",res);
    }
}
```
### 代码随想录解法：int数组储存path，需要显性回溯
